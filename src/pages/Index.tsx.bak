import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Card } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { toast } from "@/hooks/use-toast";
import ProcessProgress from "@/components/ProcessProgress";
import ResultDisplay from "@/components/ResultDisplay";
import ooc from "out-of-character";
import { LocalHumanizer } from '../utils/localHumanizer';

const Index = () => {
  const [inputText, setInputText] = useState("");
  const [isProcessing, setIsProcessing] = useState(false);
  const [currentStep, setCurrentStep] = useState(0);
  const [processSteps, setProcessSteps] = useState<string[]>([]);
  const [finalResult, setFinalResult] = useState<string>("");
  const [processLog, setProcessLog] = useState<string[]>([]);

  const steps = [
    "Traduciendo a inglés",
    "Humanizando con IA",
    "Limpiando rastros de IA (Smodin)",
    "Mejorando escritura",
    "Parafraseando texto",
    "Eliminando formato",
    "Parafraseando texto (de nuevo)",
    "Traduciendo de vuelta al español",
    "Detectando IA en resultado",
    "Verificación final"
  ];

  const addToLog = (message: string) => {
    setProcessLog(prev => [...prev, `${new Date().toLocaleTimeString()}: ${message}`]);
    console.log(message);
  };

  const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

  const translateText = async (text: string, fromLang: string, toLang: string): Promise<string> => {
    addToLog(`Traduciendo de ${fromLang} a ${toLang} (usando backend local)`);
    
    try {
      const response = await fetch("http://localhost:3001/api/translate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text, fromLang, toLang }),
      });
      
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      
      const data = await response.json();
      addToLog(`Traducción exitosa a ${toLang}.`);
      return data.result;
    } catch (error) {
      console.error("Error en la traducción:", error);
      addToLog("⚠️ Traducción fallida, usando texto original");
      return text;
    }
  };

  const improveWriting = async (text: string): Promise<string> => {
    addToLog("Mejorando la escritura del texto (usando backend local)");

    try {
      const response = await fetch("http://localhost:3001/api/improve-writing", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text }),
      });
      
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      
      const data = await response.json();
      addToLog("Escritura mejorada exitosamente.");
      await delay(300);
      return data.result;
    } catch (error) {
      console.error("Error al mejorar la escritura:", error);
      addToLog("⚠️ Mejora de escritura fallida, usando texto original");
      return text;
    }
  };

  const paraphraseText = async (text: string): Promise<string> => {
    addToLog("Parafraseando el texto (usando backend local)");

  const paraphraseText = async (text: string): Promise<string> => {
    addToLog("Parafraseando el texto (usando backend local)");

    try {
      const response = await fetch("http://localhost:3001/api/paraphrase", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text }),
      });
      
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      
      const data = await response.json();
      addToLog("Parafraseo exitoso.");
      await delay(300);
      return data.result;
    } catch (error) {
      console.error("Error al parafrasear:", error);
      addToLog("⚠️ Parafraseo fallido, usando texto original");
      return text;
    }
  };

  const removeFormatting = async (text: string): Promise<string> => {
    addToLog("Eliminando formato del texto (usando out-of-character)");
    const cleanedText = ooc.replace(text); 
    addToLog("Formato eliminado exitosamente.");
    await delay(500); // Mantener un pequeño delay para simular el procesamiento real
    return cleanedText;
  };

  const humanizeText = async (text: string, lang: string = "en"): Promise<string> => {
    addToLog("Humanizando el texto con IA (usando backend local)");
    try {
      const response = await fetch("http://localhost:3001/api/humanize", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text, lang }),
      });
      const data = await response.json();
      if (data.result) {
        addToLog("✅ Texto humanizado exitosamente");
        return data.result;
      } else {
        throw new Error(data.error || "Error desconocido");
      }
    } catch (error) {
      console.error("Error en la humanización:", error);
      addToLog("❌ Error en la humanización del texto");
      return text;
    }
  };

  const detectAI = async (text: string): Promise<{ isAI: boolean; confidence: number }> => {
    addToLog("Detectando contenido de IA (usando backend local)");

    try {
      const response = await fetch("http://localhost:3001/api/detect-ai", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text }),
      });
      
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      
      const data = await response.json();
      addToLog(`✅ Detección de IA completada: ${data.confidence.toFixed(2)}% (${data.isAI ? "Contenido IA" : "Contenido humano"})`);
      return { isAI: data.isAI, confidence: data.confidence };
    } catch (error) {
      console.error("Error en la detección de IA:", error);
      addToLog("⚠️ Detección de IA fallida");
      return { isAI: false, confidence: 0 };
    }
  };

  const removeAIDetectionSmodin = async (text: string, language: string = "es"): Promise<string> => {
    addToLog("Limpiando rastros de IA con Smodin (AI Content Detection Remover)");
    const RAPIDAPI_KEY = "4cc1e4b4camshcb8e9b0028cb710p1e18f2jsnde3df39a0a8e"; 
    const API_ENDPOINT = "https://ai-content-detection-remover.p.rapidapi.com/recreate";
    try {
      const response = await fetch(API_ENDPOINT, {
        method: 'POST',
        headers: {
          'content-type': 'application/json',
          'x-rapidapi-key': RAPIDAPI_KEY,
          'x-rapidapi-host': 'ai-content-detection-remover.p.rapidapi.com'
        },
        body: JSON.stringify({
          text,
          language,
          recreateType: "aiDetection"
        })
      });
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      const data = await response.json();
      console.log("Respuesta Smodin:", data);
      if (!data.recreate) throw new Error("Respuesta inesperada de Smodin");
      addToLog("Texto limpiado exitosamente por Smodin.");
      return data.recreate;
    } catch (error) {
      console.error("Error con Smodin:", error);
      toast({
        title: "Error de Smodin",
        description: `No se pudo limpiar el texto con Smodin. Detalles: ${(error as Error).message}`,
        variant: "destructive"
      });
      return text; // Devuelve el texto original si falla
    }
  };

  const startHumanizationProcess = async () => {
    if (!inputText.trim()) {
      toast({
        title: "Error",
        description: "Por favor ingresa el texto a humanizar",
        variant: "destructive"
      });
      return;
    }

    setIsProcessing(true);
    setCurrentStep(0);
    setProcessLog([]);
    setFinalResult("");

    try {
      let currentText = inputText;
      let aiDetection = { isAI: false, confidence: 0 };

      // Paso 1: Traducir a inglés (Ahora local ✅)
      setCurrentStep(1);
      currentText = await translateText(currentText, 'es', 'en');

      // Paso 2: Humanizar con IA ✅
      setCurrentStep(2);
      currentText = await humanizeText(currentText, 'en');

      // Paso 3: Limpiar rastros de IA con Smodin
      setCurrentStep(3);
      currentText = await removeAIDetectionSmodin(currentText);

      // Paso 4: Mejorar escritura (Ahora local ✅)
      setCurrentStep(4);
      currentText = await improveWriting(currentText);

      // Paso 5: Parafrasear (Ahora local ✅)
      setCurrentStep(5);
      currentText = await paraphraseText(currentText);

      // Paso 6: Eliminar formato
      setCurrentStep(6);
      currentText = await removeFormatting(currentText);

      // Paso 7: Parafrasear de nuevo (Ahora local ✅)
      setCurrentStep(7);
      currentText = await paraphraseText(currentText);

      // Paso 8: Traducir de vuelta al español (Ahora local ✅)
      setCurrentStep(8);
      currentText = await translateText(currentText, 'en', 'es');

      // Paso 9: Detectar IA (Ahora local ✅)
      setCurrentStep(9);
      aiDetection = await detectAI(currentText);

      // Paso 10: Verificación final
      setCurrentStep(10);
      addToLog(`✅ Proceso completado. Confianza IA: ${aiDetection.confidence.toFixed(2)}%`);

      toast({
        title: "Éxito",
        description: "Texto humanizado correctamente con transformaciones locales y IA"
      });

      setFinalResult(currentText);

    } catch (error) {
      console.error("Error en el proceso:", error);
      toast({
        title: "Error",
        description: "Hubo un error durante el proceso de humanización: " + (error as Error).message,
        variant: "destructive"
      });
    } finally {
      setIsProcessing(false);
      setCurrentStep(0);
    }
  };

  const resetProcess = () => {
    setInputText("");
    setFinalResult("");
    setProcessLog([]);
    setCurrentStep(0);
  };

  return (
    <div className="min-h-screen bg-background flex flex-col items-center p-4 sm:p-6 lg:p-8 font-serif">
      <div className="w-full max-w-6xl mx-auto flex flex-col flex-grow">
        <header className="text-center mb-12 flex-shrink-0">
          <h1 className="text-4xl sm:text-5xl font-sans font-bold mb-3">
            Agente Humanizador de Texto
          </h1>
          <p className="text-lg text-foreground/80 max-w-2xl mx-auto">
            Transforma contenido generado por IA en una escritura natural, auténtica y que conecte con tu audiencia.
          </p>
        </header>

        <main className="grid grid-cols-1 lg:grid-cols-2 gap-8 flex-grow">
          {/* Columna de Input */}
          <Card className="p-6 sm:p-8 shadow-lg flex flex-col">
            <label htmlFor="input-text" className="block text-lg font-sans font-semibold mb-4 text-foreground flex-shrink-0">
              Pega tu texto aquí
            </label>
            <Textarea
              id="input-text"
              placeholder="El texto de IA que deseas transformar..."
              value={inputText}
              onChange={(e) => setInputText(e.target.value)}
              className="flex-grow mb-4 text-base rounded-md resize-none"
              disabled={isProcessing}
            />
            <div className="flex flex-col sm:flex-row gap-4 mt-auto flex-shrink-0">
              <Button
                onClick={startHumanizationProcess}
                disabled={isProcessing || !inputText.trim()}
                className="w-full sm:w-auto flex-grow py-3 text-lg font-sans"
                size="lg"
              >
                {isProcessing ? "Procesando..." : "Humanizar Texto"}
              </Button>
              <Button
                variant="outline"
                onClick={resetProcess}
                disabled={isProcessing}
                className="w-full sm:w-auto py-3 text-lg font-sans"
                size="lg"
              >
                Limpiar
              </Button>
            </div>
          </Card>

          {/* Columna de Output */}
          <Card className="p-6 sm:p-8 shadow-lg flex flex-col">
            <h2 className="text-2xl font-sans font-semibold mb-4 text-foreground flex-shrink-0">Resultado Humanizado</h2>
            <div className="flex-grow flex flex-col justify-center border-2 border-dashed border-border/20 rounded-lg p-4 bg-background">
              {!finalResult && (
                <div className="text-center text-foreground/60">
                  <p>{isProcessing ? "Procesando y mejorando el texto..." : "El resultado aparecerá aquí."}</p>
                </div>
              )}
              {finalResult && <ResultDisplay result={finalResult} />}
            </div>
          </Card>
        </main>

        {(isProcessing || processLog.length > 0) && (
          <section className="w-full mt-8">
            {isProcessing && (
              <div className="w-full">
                <ProcessProgress
                  steps={steps}
                  currentStep={currentStep}
                  isProcessing={isProcessing}
                />
              </div>
            )}

            {processLog.length > 0 && (
              <Card className="mt-8 p-6 shadow-md bg-card/50">
                <h3 className="text-xl font-sans font-semibold mb-4 text-foreground">Registro del Proceso</h3>
                <div className="bg-secondary/10 rounded-lg p-4 max-h-48 overflow-y-auto border border-border">
                  {processLog.map((log, index) => (
                    <div key={index} className="text-sm text-foreground/90 mb-1 font-mono">
                      {log}
                    </div>
                  ))}
                </div>
              </Card>
            )}
          </section>
        )}

        <footer className="text-center mt-12 flex-shrink-0">
            <Alert className="border-none bg-transparent">
              <AlertDescription className="text-foreground/60">
                <strong>Nota:</strong> Esta es una herramienta en desarrollo. Revisa siempre los resultados.
              </AlertDescription>
            </Alert>
        </footer>

      </div>
    </div>
  );
};

export default Index;
